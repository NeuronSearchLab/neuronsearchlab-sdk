{"version":3,"sources":["../src/logger.ts","../src/index.ts"],"sourcesContent":["export type LogLevelName = \"TRACE\" | \"DEBUG\" | \"INFO\" | \"WARN\" | \"ERROR\" | \"FATAL\";\n\nconst LEVEL_VALUES: Record<LogLevelName, number> = {\n  TRACE: 10,\n  DEBUG: 20,\n  INFO: 30,\n  WARN: 40,\n  ERROR: 50,\n  FATAL: 60,\n};\n\nexport type StructuredLogEntry = {\n  level: LogLevelName;\n  levelValue: number;\n  message: string;\n  timestamp: string;\n  context?: Record<string, unknown>;\n};\n\nexport type LoggerTransport = (entry: StructuredLogEntry) => void;\n\nexport type LoggerConfig = {\n  /**\n   * Global log level. TRACE is the most verbose, FATAL is the most quiet.\n   * Defaults to INFO for production-friendly output.\n   */\n  level?: LogLevelName | number;\n  /**\n   * When true, request/response bodies will be included in TRACE/DEBUG logs.\n   * Remains disabled by default to avoid leaking sensitive data.\n   */\n  enableNetworkBodyLogging?: boolean;\n  /**\n   * Enables timing/metric logging around HTTP calls. Disabled by default.\n   */\n  enablePerformanceLogging?: boolean;\n  /**\n   * Provide a custom log transport (e.g., ship logs to your own logger).\n   * Defaults to console.* for quick observability.\n   */\n  transport?: LoggerTransport;\n  /**\n   * Keys (case-sensitive) that should never be emitted. Defaults to common\n   * credential keys to guarantee that INFO/WARN/ERROR logs stay safe.\n   */\n  redactKeys?: string[];\n};\n\nconst DEFAULT_CONFIG: Required<Omit<LoggerConfig, \"transport\">> & {\n  transport: LoggerTransport;\n} = {\n  level: \"INFO\",\n  enableNetworkBodyLogging: false,\n  enablePerformanceLogging: false,\n  redactKeys: [\"accessToken\", \"authorization\", \"Authorization\"],\n  transport(entry) {\n    const method =\n      entry.level === \"TRACE\" || entry.level === \"DEBUG\"\n        ? \"debug\"\n        : entry.level === \"INFO\"\n          ? \"info\"\n          : entry.level === \"WARN\"\n            ? \"warn\"\n            : \"error\";\n    const prefix = `[NeuronSDK][${entry.level}] ${entry.message}`;\n    if (entry.context && Object.keys(entry.context).length > 0) {\n      console[method]?.(prefix, entry.context);\n    } else {\n      console[method]?.(prefix);\n    }\n  },\n};\n\nconst NETWORK_BODY_KEYS = new Set([\"requestBody\", \"responseBody\"]);\n\nexport class SDKLogger {\n  private config: Required<LoggerConfig>;\n  private levelValue: number;\n\n  constructor() {\n    this.config = {...DEFAULT_CONFIG};\n    this.levelValue = this.toLevelValue(this.config.level);\n  }\n\n  /**\n   * Configure the global logger.\n   *\n   * Development example (verbose logging + payloads):\n   * ```ts\n   * import {configureLogger} from \"@neuronsearchlab/sdk\";\n   * configureLogger({\n   *   level: \"TRACE\",\n   *   enableNetworkBodyLogging: true,\n   *   enablePerformanceLogging: true,\n   * });\n   * ```\n   *\n   * Production example (safe defaults):\n   * ```ts\n   * configureLogger({ level: \"INFO\" });\n   * ```\n   */\n  public configure(config: LoggerConfig = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n      transport: config.transport ?? this.config.transport,\n      redactKeys: config.redactKeys ?? this.config.redactKeys,\n    };\n    if (config.level !== undefined) {\n      this.levelValue = this.toLevelValue(config.level);\n      this.config.level = this.levelValueToName(this.levelValue);\n    }\n  }\n\n  public shouldLog(level: LogLevelName): boolean {\n    return this.toLevelValue(level) >= this.levelValue;\n  }\n\n  public isPerformanceLoggingEnabled(): boolean {\n    return this.config.enablePerformanceLogging && this.shouldLog(\"DEBUG\");\n  }\n\n  public canLogNetworkPayloads(level: LogLevelName): boolean {\n    return (\n      this.config.enableNetworkBodyLogging &&\n      this.shouldLog(level) &&\n      this.toLevelValue(level) <= this.toLevelValue(\"DEBUG\")\n    );\n  }\n\n  public trace(message: string, context?: Record<string, unknown>) {\n    this.log(\"TRACE\", message, context);\n  }\n\n  public debug(message: string, context?: Record<string, unknown>) {\n    this.log(\"DEBUG\", message, context);\n  }\n\n  public info(message: string, context?: Record<string, unknown>) {\n    this.log(\"INFO\", message, context);\n  }\n\n  public warn(message: string, context?: Record<string, unknown>) {\n    this.log(\"WARN\", message, context);\n  }\n\n  public error(message: string, context?: Record<string, unknown>) {\n    this.log(\"ERROR\", message, context);\n  }\n\n  public fatal(message: string, context?: Record<string, unknown>) {\n    this.log(\"FATAL\", message, context);\n  }\n\n  private log(level: LogLevelName, message: string, context?: Record<string, unknown>) {\n    if (!this.shouldLog(level)) return;\n    const entry: StructuredLogEntry = {\n      level,\n      levelValue: this.toLevelValue(level),\n      message,\n      timestamp: new Date().toISOString(),\n      context: this.sanitizeContext(level, context),\n    };\n    this.config.transport(entry);\n  }\n\n  private sanitizeContext(\n    level: LogLevelName,\n    context?: Record<string, unknown>\n  ): Record<string, unknown> | undefined {\n    if (!context) return undefined;\n    const sanitized: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(context)) {\n      if (this.config.redactKeys.includes(key)) {\n        sanitized[key] = \"[REDACTED]\";\n        continue;\n      }\n      if (\n        NETWORK_BODY_KEYS.has(key) &&\n        !(this.canLogNetworkPayloads(level) && typeof value !== \"undefined\")\n      ) {\n        continue;\n      }\n      sanitized[key] = value;\n    }\n    return Object.keys(sanitized).length > 0 ? sanitized : undefined;\n  }\n\n  private toLevelValue(level: LogLevelName | number): number {\n    if (typeof level === \"number\") {\n      return level;\n    }\n    return LEVEL_VALUES[level];\n  }\n\n  private levelValueToName(value: number): LogLevelName {\n    const found = (Object.entries(LEVEL_VALUES) as [LogLevelName, number][]).find(\n      ([, v]) => v === value\n    );\n    return found?.[0] ?? \"INFO\";\n  }\n}\n\nexport const logger = new SDKLogger();\nexport const configureLogger = (config: LoggerConfig) => logger.configure(config);\nexport type {LogLevelName as LogLevel};\n","// src/index.ts\n\nimport {logger} from \"./logger\";\n\nexport {configureLogger, logger} from \"./logger\";\nexport type {\n  LogLevel,\n  LoggerConfig,\n  StructuredLogEntry,\n  LoggerTransport,\n} from \"./logger\";\n\nexport type SDKConfig = {\n  baseUrl: string; // e.g. https://api.neuronsearchlab.com/v1\n  accessToken: string; // Bearer token\n  timeoutMs?: number; // default 10_000\n  maxRetries?: number; // retry on 429/5xx/timeouts, default 2\n  fetchImpl?: typeof fetch; // custom fetch (e.g., undici/node-fetch for older Node)\n  collateWindowSeconds?: number; // buffer events for this many seconds before flushing; default 3\n  maxBatchSize?: number; // flush immediately once this many events are buffered; default 200\n  maxBufferedEvents?: number; // drop oldest events past this limit; default 5000\n  maxEventRetries?: number; // max send retries for buffered events after network failure; default 5\n  disableArrayBatching?: boolean; // force single-event sends (used after server rejects arrays)\n\n  /**\n   * ✅ NEW: request_id propagation\n   * If true (default), the SDK will remember the latest request_id returned by\n   * /recommendations and automatically attach it to subsequent trackEvent calls\n   * (unless you explicitly pass requestId in the event payload).\n   */\n  propagateRecommendationRequestId?: boolean;\n};\n\nexport type APIErrorBody = {\n  error?: string;\n  message?: string;\n  code?: string | number;\n  details?: unknown;\n  [k: string]: unknown;\n};\n\nexport class SDKHttpError extends Error {\n  public status: number;\n  public statusText: string;\n  public body?: APIErrorBody | string;\n\n  constructor(\n    msg: string,\n    opts: {status: number; statusText: string; body?: APIErrorBody | string}\n  ) {\n    super(msg);\n    this.name = \"SDKHttpError\";\n    this.status = opts.status;\n    this.statusText = opts.statusText;\n    this.body = opts.body;\n  }\n}\n\nexport class SDKTimeoutError extends Error {\n  constructor(public timeoutMs: number) {\n    super(`Request timed out after ${timeoutMs} ms`);\n    this.name = \"SDKTimeoutError\";\n  }\n}\n\n// -------- Domain payloads --------\n\n// ✅ Backwards compatible: allow requestId/request_id on event payloads\nexport type TrackEventPayload = {\n  eventId: number; // numeric, defined in admin UI\n  userId: number | string;\n  itemId: number | string; // allow UUIDs or numeric IDs\n\n  // optional correlation id (recommended)\n  requestId?: string;\n  request_id?: string;\n\n  [k: string]: unknown;\n};\n\nexport type ItemUpsertPayload = {\n  itemId: number | string; // allow UUIDs or numeric IDs\n  name: string;\n  description: string;\n  metadata: Record<string, any>;\n};\n\nexport type RecommendationOptions = {\n  userId: number | string;\n  contextId?: string;\n  limit?: number;\n};\n\nexport type AutoRecommendationsOptions = {\n  userId: number | string;\n  contextId?: string; // optional: apply the same context filters while filling auto sections\n  limit?: number; // quantity per section\n  cursor?: string; // pass the last next_cursor returned by the API\n  windowDays?: number; // optional override; API may choose to honor cursor continuity\n  candidateLimit?: number; // optional tuning\n  servedCap?: number; // optional tuning\n};\n\nexport type DeleteItemInput = {\n  itemId: string | number;\n};\n\nexport type DeleteItemsResponse = {\n  message: string;\n  itemId?: string | number;\n  itemIds: Array<string | number>;\n  deletedCount?: number;\n  processing_time_ms?: number;\n};\n\n// ✅ NEW: PATCH payload + response\nexport type PatchItemInput = {\n  itemId: string | number;\n  active?: boolean;\n  [k: string]: unknown;\n};\n\nexport type PatchItemResponse = {\n  message: string;\n  itemId: string | number;\n  active?: boolean;\n  processing_time_ms?: number;\n};\n\n// Updated response type to match API (incl. request_id)\nexport type RecommendationsResponse = {\n  message?: string;\n\n  // ✅ NEW: correlation id from API\n  request_id?: string;\n\n  embedding_info?: {\n    source: string;\n    used_default: boolean;\n    default_reason?: string | null;\n    dimension: number;\n    expected_dimension: number;\n    averaged_interactions?: number;\n  };\n  upserted_embedding_row?: {\n    tenant_id: string;\n    entity_id: string;\n    name: string;\n    description: string;\n    entity_type: string;\n    created_at: string;\n    last_modified: string;\n    embedding: string;\n  };\n  recommendations: Array<{\n    entity_id: string;\n    name: string;\n    description: string;\n    score: number;\n    metadata?: Record<string, any>;\n    embedding?: number[];\n  }>;\n  quantity?: number;\n  excluded_viewed_items?: {\n    value: number | null;\n    unit: string;\n    interval: string | null;\n  } | null;\n  processing_time_ms?: number;\n\n  // mode=auto support (backwards compatible)\n  mode?: \"auto\" | \"single\" | string;\n  section?: {\n    section_id: string;\n    title: string;\n    reason: Record<string, any>;\n  } | null;\n  next_cursor?: string | null;\n  done?: boolean;\n};\n\n// Legacy type for backwards compatibility\nexport type Recommendation = {\n  itemId: number | string;\n  score?: number;\n  reason?: string;\n  [k: string]: unknown;\n};\n\ntype BufferedEvent<T> = {\n  payload: T;\n  resolve: (value: any) => void;\n  reject: (err: any) => void;\n  retries: number;\n  enqueueTime: number;\n};\n\nexport class NeuronSDK {\n  private baseUrl: string;\n  private accessToken: string;\n  private timeoutMs: number;\n  private maxRetries: number;\n  private fetchImpl: typeof fetch;\n  private collateWindowMs: number;\n  private maxBatchSize: number;\n  private maxBufferedEvents: number;\n  private maxEventRetries: number;\n  private disableArrayBatching: boolean;\n  private eventBuffer: BufferedEvent<any>[] = [];\n  private flushTimer: ReturnType<typeof setTimeout> | null = null;\n  private isFlushing = false;\n  private pendingFlushPromise: Promise<void> | null = null;\n  private flushRetryCount = 0;\n  private lifecycleListenersRegistered = false;\n  private arrayBatchingRejected = false;\n\n  // ✅ request_id propagation state\n  private propagateRecommendationRequestId: boolean;\n  private lastRecommendationRequestId: string | null = null;\n\n  constructor(config: SDKConfig) {\n    if (!config.baseUrl || !config.accessToken) {\n      throw new Error(\"baseUrl and accessToken are required\");\n    }\n    this.baseUrl = config.baseUrl.replace(/\\/+$/, \"\"); // trim trailing slashes\n    this.accessToken = config.accessToken;\n    this.timeoutMs = config.timeoutMs ?? 10_000;\n    this.maxRetries = config.maxRetries ?? 2;\n    this.fetchImpl = config.fetchImpl ?? (globalThis.fetch as typeof fetch);\n    this.collateWindowMs = (config.collateWindowSeconds ?? 3) * 1000;\n    this.maxBatchSize = config.maxBatchSize ?? 200;\n    this.maxBufferedEvents = config.maxBufferedEvents ?? 5000;\n    this.maxEventRetries = config.maxEventRetries ?? 5;\n    this.disableArrayBatching = Boolean(config.disableArrayBatching);\n\n    this.propagateRecommendationRequestId =\n      config.propagateRecommendationRequestId ?? true;\n\n    if (!this.fetchImpl) {\n      throw new Error(\n        \"fetch is not available in this environment. Provide config.fetchImpl (e.g., undici or node-fetch).\"\n      );\n    }\n\n    this.registerLifecycleFlush();\n  }\n\n  private registerLifecycleFlush() {\n    if (this.lifecycleListenersRegistered) return;\n\n    if (\n      typeof window !== \"undefined\" &&\n      typeof window.addEventListener === \"function\"\n    ) {\n      const handler = () => {\n        void this.flushEvents({useBeacon: true});\n      };\n\n      window.addEventListener(\"beforeunload\", handler);\n      window.addEventListener(\"pagehide\", handler);\n      window.addEventListener(\"visibilitychange\", () => {\n        if (\n          typeof document !== \"undefined\" &&\n          document.visibilityState === \"hidden\"\n        ) {\n          handler();\n        }\n      });\n      this.lifecycleListenersRegistered = true;\n    }\n  }\n\n  public setAccessToken(token: string) {\n    this.accessToken = token;\n  }\n\n  public setBaseUrl(url: string) {\n    this.baseUrl = url.replace(/\\/+$/, \"\");\n  }\n\n  public setTimeout(ms: number) {\n    this.timeoutMs = ms;\n  }\n\n  /**\n   * ✅ NEW: Let callers manually set/override the current request_id\n   * (useful if you want to correlate a whole page session yourself).\n   */\n  public setRequestId(requestId: string | null) {\n    this.lastRecommendationRequestId =\n      requestId && requestId.trim() ? requestId.trim() : null;\n  }\n\n  /**\n   * ✅ NEW: Read the last request_id captured from /recommendations\n   */\n  public getRequestId(): string | null {\n    return this.lastRecommendationRequestId;\n  }\n\n  private getHeaders(extra?: HeadersInit): HeadersInit {\n    return {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.accessToken}`,\n      ...(extra ?? {}),\n    };\n  }\n\n  // Core request with timeout + retry (429/5xx + timeouts)\n  private async request<T>(\n    pathOrUrl: string,\n    init: RequestInit & {retryOn?: number[]} = {}\n  ): Promise<T> {\n    const method = init.method ?? \"GET\";\n    const isAbs = /^https?:\\/\\//i.test(pathOrUrl);\n    const url = isAbs\n      ? pathOrUrl\n      : `${this.baseUrl}${pathOrUrl.startsWith(\"/\") ? \"\" : \"/\"}${pathOrUrl}`;\n\n    const retryOn = init.retryOn ?? [429, 500, 502, 503, 504];\n    let attempt = 0;\n    const requestId =\n      logger.shouldLog(\"DEBUG\") || logger.isPerformanceLoggingEnabled()\n        ? `${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`\n        : undefined;\n\n    while (true) {\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), this.timeoutMs);\n      const startTime = logger.isPerformanceLoggingEnabled() ? Date.now() : 0;\n\n      if (logger.shouldLog(\"DEBUG\")) {\n        logger.debug(\"HTTP request attempt\", {\n          method,\n          url,\n          attempt,\n          maxRetries: this.maxRetries,\n          retryOn,\n          requestId,\n          requestBody: typeof init.body === \"string\" ? init.body : undefined,\n        });\n      }\n\n      try {\n        const res = await this.fetchImpl(url, {\n          ...init,\n          signal: controller.signal,\n        });\n        clearTimeout(timeout);\n        const durationMs = startTime ? Date.now() - startTime : undefined;\n\n        if (res.ok) {\n          const text = await res.text();\n          if (logger.shouldLog(\"DEBUG\")) {\n            logger.debug(\"HTTP response received\", {\n              method,\n              url,\n              attempt,\n              status: res.status,\n              requestId,\n              durationMs,\n            });\n          }\n          if (text && logger.shouldLog(\"TRACE\")) {\n            logger.trace(\"HTTP response payload\", {\n              method,\n              url,\n              requestId,\n              responseBody: text,\n            });\n          }\n          if (!text) return undefined as unknown as T;\n          try {\n            return JSON.parse(text) as T;\n          } catch {\n            return text as unknown as T;\n          }\n        }\n\n        const raw = await res.text().catch(() => \"\");\n        if (logger.shouldLog(\"WARN\")) {\n          logger.warn(\"HTTP response not OK\", {\n            method,\n            url,\n            attempt,\n            status: res.status,\n            statusText: res.statusText,\n            requestId,\n            durationMs,\n            responseBody: raw,\n          });\n        }\n\n        let body: APIErrorBody | string | undefined;\n        try {\n          body = raw ? (JSON.parse(raw) as APIErrorBody) : undefined;\n        } catch {\n          body = raw;\n        }\n\n        if (retryOn.includes(res.status) && attempt < this.maxRetries) {\n          attempt++;\n          const retryAfter = res.headers.get(\"retry-after\");\n          const delay =\n            retryAfter && !Number.isNaN(Number(retryAfter))\n              ? Number(retryAfter) * 1000\n              : this.backoffMs(attempt);\n\n          if (logger.shouldLog(\"INFO\")) {\n            logger.info(\"Retrying request after HTTP status\", {\n              method,\n              url,\n              attempt,\n              status: res.status,\n              delayMs: delay,\n              requestId,\n            });\n          }\n          await this.sleep(delay);\n          continue;\n        }\n\n        const msg = `HTTP ${res.status} ${res.statusText} for ${method} ${url}`;\n        throw new SDKHttpError(msg, {\n          status: res.status,\n          statusText: res.statusText,\n          body,\n        });\n      } catch (err: any) {\n        clearTimeout(timeout);\n\n        if (err?.name === \"AbortError\") {\n          if (attempt < this.maxRetries) {\n            attempt++;\n            if (logger.shouldLog(\"WARN\")) {\n              logger.warn(\"Retrying request after timeout\", {\n                method,\n                url,\n                attempt,\n                timeoutMs: this.timeoutMs,\n                requestId,\n              });\n            }\n            await this.sleep(this.backoffMs(attempt));\n            continue;\n          }\n\n          logger.error(\"Request aborted after max retries\", {\n            method,\n            url,\n            attempts: attempt,\n            timeoutMs: this.timeoutMs,\n            requestId,\n          });\n          throw new SDKTimeoutError(this.timeoutMs);\n        }\n\n        if (attempt < this.maxRetries) {\n          attempt++;\n          if (logger.shouldLog(\"WARN\")) {\n            logger.warn(\"Retrying request after network error\", {\n              method,\n              url,\n              attempt,\n              error: err?.message,\n              requestId,\n            });\n          }\n          await this.sleep(this.backoffMs(attempt));\n          continue;\n        }\n\n        logger.error(\"Request failed\", {\n          method,\n          url,\n          attempts: attempt,\n          error: err?.message,\n          requestId,\n        });\n        throw err;\n      }\n    }\n  }\n\n  private backoffMs(attempt: number) {\n    const base = 300 * Math.pow(2, attempt - 1);\n    const jitter = Math.random() * 200;\n    return base + jitter;\n  }\n\n  private sleep(ms: number) {\n    return new Promise((r) => setTimeout(r, ms));\n  }\n\n  private scheduleFlush(delayMs?: number) {\n    if (this.flushTimer) {\n      if (typeof delayMs === \"number\") {\n        clearTimeout(this.flushTimer);\n        this.flushTimer = setTimeout(() => void this.flushEvents(), delayMs);\n      }\n      return;\n    }\n    const waitMs = typeof delayMs === \"number\" ? delayMs : this.collateWindowMs;\n    this.flushTimer = setTimeout(() => void this.flushEvents(), waitMs);\n  }\n\n  private trimBufferIfNeeded(incomingCount = 0) {\n    const overflow =\n      this.eventBuffer.length + incomingCount - this.maxBufferedEvents;\n    if (overflow > 0) {\n      const dropped = this.eventBuffer.splice(0, overflow);\n      if (logger.shouldLog(\"WARN\")) {\n        logger.warn(\"Dropping buffered events due to maxBufferedEvents limit\", {\n          maxBufferedEvents: this.maxBufferedEvents,\n          dropped: overflow,\n        });\n      }\n      dropped.forEach((evt) =>\n        evt.reject(\n          new Error(\n            \"Event dropped because the buffer exceeded maxBufferedEvents\"\n          )\n        )\n      );\n    }\n  }\n\n  private enqueueEvent<TResponse>(payload: any): Promise<TResponse> {\n    return new Promise<TResponse>((resolve, reject) => {\n      this.trimBufferIfNeeded(1);\n\n      this.eventBuffer.push({\n        payload,\n        resolve,\n        reject,\n        retries: 0,\n        enqueueTime: Date.now(),\n      });\n\n      if (this.eventBuffer.length >= this.maxBatchSize) {\n        void this.flushEvents();\n      } else {\n        this.scheduleFlush();\n      }\n    });\n  }\n\n  public async flushEvents(options: {useBeacon?: boolean} = {}): Promise<void> {\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n      this.flushTimer = null;\n    }\n    if (this.isFlushing || this.eventBuffer.length === 0) {\n      return this.pendingFlushPromise ?? Promise.resolve();\n    }\n    this.isFlushing = true;\n\n    const promise = (async () => {\n      while (this.eventBuffer.length > 0) {\n        const batch = this.eventBuffer.splice(0, this.maxBatchSize);\n        try {\n          const response = await this.sendBatch(batch, options);\n          batch.forEach((entry) => entry.resolve(response));\n          this.flushRetryCount = 0;\n        } catch (err: any) {\n          this.eventBuffer = batch.concat(this.eventBuffer);\n          this.trimBufferIfNeeded();\n          this.flushRetryCount += 1;\n          const willRetry = this.flushRetryCount <= this.maxEventRetries;\n\n          if (logger.shouldLog(willRetry ? \"WARN\" : \"ERROR\")) {\n            logger[willRetry ? \"warn\" : \"error\"](\n              willRetry\n                ? \"Failed to send events, scheduling retry\"\n                : \"Dropping events after max retries\",\n              {\n                attempt: this.flushRetryCount,\n                maxEventRetries: this.maxEventRetries,\n                error: err?.message,\n                bufferedCount: this.eventBuffer.length,\n              }\n            );\n          }\n\n          if (willRetry) {\n            this.scheduleFlush(this.backoffMs(this.flushRetryCount));\n          } else {\n            const dropError = new Error(\n              \"Max retries reached while sending buffered events\"\n            );\n            batch.forEach((entry) => entry.reject(dropError));\n          }\n          break;\n        }\n      }\n    })();\n\n    this.pendingFlushPromise = promise.finally(() => {\n      this.isFlushing = false;\n      this.pendingFlushPromise = null;\n    });\n\n    return this.pendingFlushPromise;\n  }\n\n  private async sendBatch(\n    batch: BufferedEvent<any>[],\n    options: {useBeacon?: boolean}\n  ): Promise<any> {\n    const shouldSendArray =\n      batch.length > 1 &&\n      !this.disableArrayBatching &&\n      !this.arrayBatchingRejected;\n\n    if (shouldSendArray) {\n      try {\n        return await this.postEvents(\n          batch.map((entry) => entry.payload),\n          options\n        );\n      } catch (err: any) {\n        if (!this.arrayBatchingRejected && err instanceof SDKHttpError) {\n          this.arrayBatchingRejected = true;\n          if (logger.shouldLog(\"WARN\")) {\n            logger.warn(\n              \"Array payload rejected, falling back to single-event sends\",\n              {\n                status: err.status,\n                statusText: err.statusText,\n              }\n            );\n          }\n          return this.sendIndividually(batch, options);\n        }\n        throw err;\n      }\n    }\n\n    return this.sendIndividually(batch, options);\n  }\n\n  private async sendIndividually(\n    batch: BufferedEvent<any>[],\n    options: {useBeacon?: boolean}\n  ): Promise<any> {\n    let lastResponse: any;\n    for (const entry of batch) {\n      lastResponse = await this.postEvents(entry.payload, options);\n    }\n    return lastResponse;\n  }\n\n  private async postEvents(payload: any, options: {useBeacon?: boolean}) {\n    const body = JSON.stringify(payload);\n    return this.request(\"/events\", {\n      method: \"POST\",\n      headers: this.getHeaders(),\n      body,\n      keepalive: Boolean(options.useBeacon),\n    });\n  }\n\n  // ----------------- Public API -----------------\n\n  /**\n   * Track an existing event occurrence.\n   * POST /events\n   */\n  public async trackEvent<T = {success: true; id?: number}>(\n    data: TrackEventPayload\n  ): Promise<T> {\n    if (\n      !data ||\n      typeof data.eventId !== \"number\" ||\n      (typeof data.userId !== \"number\" && typeof data.userId !== \"string\") ||\n      (typeof data.itemId !== \"number\" && typeof data.itemId !== \"string\")\n    ) {\n      throw new Error(\n        \"eventId must be a number; userId and itemId must be a string or number\"\n      );\n    }\n\n    // ✅ attach request_id if:\n    // - propagation enabled\n    // - caller didn't provide one\n    // - we have one captured from /recommendations\n    const existingRid =\n      typeof (data as any).requestId === \"string\"\n        ? (data as any).requestId\n        : typeof (data as any).request_id === \"string\"\n        ? (data as any).request_id\n        : undefined;\n\n    const ridToAttach =\n      !existingRid && this.propagateRecommendationRequestId\n        ? this.lastRecommendationRequestId ?? undefined\n        : undefined;\n\n    const payload = {\n      ...data,\n      ...(ridToAttach ? {request_id: ridToAttach} : {}),\n      client_ts: new Date().toISOString(),\n    };\n\n    return this.enqueueEvent<T>(payload);\n  }\n\n  /**\n   * @deprecated Use trackEvent(). Kept for backwards compatibility.\n   */\n  public async createEvent<T = {success: true; id?: number}>(\n    data: TrackEventPayload\n  ): Promise<T> {\n    return this.trackEvent<T>(data);\n  }\n\n  /**\n   * Create or update an item\n   * POST /items\n   */\n  public async upsertItem<T = {success: true; itemId: number | string}>(\n    data: ItemUpsertPayload\n  ): Promise<T> {\n    return this.request<T>(\"/items\", {\n      method: \"POST\",\n      headers: this.getHeaders(),\n      body: JSON.stringify(data),\n    });\n  }\n\n  /**\n   * ✅ NEW: Patch (partial update) a single item.\n   * PATCH /items/{item_id}\n   */\n  public async patchItem<T = PatchItemResponse>(\n    input: PatchItemInput\n  ): Promise<T> {\n    const itemId = input?.itemId;\n\n    const isValidString =\n      typeof itemId === \"string\" && itemId.trim().length > 0;\n    const isValidPositiveInteger =\n      typeof itemId === \"number\" && Number.isInteger(itemId) && itemId > 0;\n\n    if (!(isValidString || isValidPositiveInteger)) {\n      throw new Error(\n        \"itemId is required and must be a UUID string or positive integer\"\n      );\n    }\n\n    // Build PATCH body (exclude itemId)\n    const {itemId: _ignore, ...patch} = input;\n\n    if (!patch || Object.keys(patch).length === 0) {\n      throw new Error(\n        \"patchItem requires at least one field to update (e.g. { active: false })\"\n      );\n    }\n\n    return this.request<T>(`/items/${encodeURIComponent(String(itemId))}`, {\n      method: \"PATCH\",\n      headers: this.getHeaders(),\n      body: JSON.stringify(patch),\n    });\n  }\n\n  /**\n   * Convenience helper: enable/disable item\n   */\n  public async setItemActive<T = PatchItemResponse>(\n    itemId: string | number,\n    active: boolean\n  ): Promise<T> {\n    return this.patchItem<T>({itemId, active});\n  }\n\n  /**\n   * Delete one or more items.\n   * DELETE /items\n   */\n  public async deleteItems<T = DeleteItemsResponse>(\n    items: DeleteItemInput | DeleteItemInput[]\n  ): Promise<T> {\n    const payload = Array.isArray(items) ? items : [items];\n\n    if (\n      payload.length === 0 ||\n      payload.some((entry) => {\n        const id = entry?.itemId;\n        const isValidString = typeof id === \"string\" && id.trim().length > 0;\n        const isValidPositiveInteger =\n          typeof id === \"number\" && Number.isInteger(id) && id > 0;\n        return !(isValidString || isValidPositiveInteger);\n      })\n    ) {\n      throw new Error(\n        \"itemId is required and must be a UUID string or positive integer\"\n      );\n    }\n\n    const body = payload.length === 1 ? payload[0] : payload;\n\n    return this.request<T>(\"/items\", {\n      method: \"DELETE\",\n      headers: this.getHeaders(),\n      body: JSON.stringify(body),\n    });\n  }\n\n  /**\n   * Get recommendations for a user\n   * GET /recommendations?user_id=...&context_id=...&quantity=...\n   *\n   * ✅ Captures request_id for correlation if present.\n   */\n  public async getRecommendations(\n    options: RecommendationOptions\n  ): Promise<RecommendationsResponse> {\n    const {userId, contextId, limit} = options;\n    if (typeof userId !== \"number\" && typeof userId !== \"string\") {\n      throw new Error(\"userId must be a string or number\");\n    }\n\n    const url = new URL(`${this.baseUrl}/recommendations`);\n    url.searchParams.set(\"user_id\", String(userId));\n    if (contextId) url.searchParams.set(\"context_id\", contextId);\n    if (typeof limit === \"number\")\n      url.searchParams.set(\"quantity\", String(limit));\n\n    const res = await this.request<RecommendationsResponse>(url.toString(), {\n      method: \"GET\",\n      headers: this.getHeaders(),\n    });\n\n    if (this.propagateRecommendationRequestId && res?.request_id) {\n      this.lastRecommendationRequestId = res.request_id;\n    }\n\n    return res;\n  }\n\n  /**\n   * Get the next auto-generated recommendation section.\n   * GET /recommendations?mode=auto&user_id=...&cursor=...&quantity=...\n   *\n   * ✅ Captures request_id for correlation if present.\n   */\n  public async getAutoRecommendations(\n    options: AutoRecommendationsOptions\n  ): Promise<RecommendationsResponse> {\n    const {\n      userId,\n      contextId,\n      limit,\n      cursor,\n      windowDays,\n      candidateLimit,\n      servedCap,\n    } = options;\n\n    if (typeof userId !== \"number\" && typeof userId !== \"string\") {\n      throw new Error(\"userId must be a string or number\");\n    }\n\n    const url = new URL(`${this.baseUrl}/recommendations`);\n    url.searchParams.set(\"mode\", \"auto\");\n    url.searchParams.set(\"user_id\", String(userId));\n    if (contextId) url.searchParams.set(\"context_id\", contextId);\n    if (typeof limit === \"number\")\n      url.searchParams.set(\"quantity\", String(limit));\n    if (cursor) url.searchParams.set(\"cursor\", cursor);\n    if (typeof windowDays === \"number\")\n      url.searchParams.set(\"window_days\", String(windowDays));\n    if (typeof candidateLimit === \"number\")\n      url.searchParams.set(\"candidate_limit\", String(candidateLimit));\n    if (typeof servedCap === \"number\")\n      url.searchParams.set(\"served_cap\", String(servedCap));\n\n    const res = await this.request<RecommendationsResponse>(url.toString(), {\n      method: \"GET\",\n      headers: this.getHeaders(),\n    });\n\n    if (this.propagateRecommendationRequestId && res?.request_id) {\n      this.lastRecommendationRequestId = res.request_id;\n    }\n\n    return res;\n  }\n}\n\nexport default NeuronSDK;\n"],"mappings":"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","names":[]}