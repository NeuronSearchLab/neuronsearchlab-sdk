{"version":3,"sources":["../src/index.ts","../src/logger.ts"],"sourcesContent":["// src/index.ts\n\nimport {logger} from \"./logger\";\n\nexport {configureLogger, logger} from \"./logger\";\nexport type {LogLevel, LoggerConfig, StructuredLogEntry, LoggerTransport} from \"./logger\";\n\nexport type SDKConfig = {\n  baseUrl: string; // e.g. https://api.neuronsearchlab.com/v1\n  accessToken: string; // Bearer token\n  timeoutMs?: number; // default 10_000\n  maxRetries?: number; // retry on 429/5xx/timeouts, default 2\n  fetchImpl?: typeof fetch; // custom fetch (e.g., undici/node-fetch for older Node)\n};\n\nexport type APIErrorBody = {\n  error?: string;\n  message?: string;\n  code?: string | number;\n  details?: unknown;\n  [k: string]: unknown;\n};\n\nexport class SDKHttpError extends Error {\n  public status: number;\n  public statusText: string;\n  public body?: APIErrorBody | string;\n\n  constructor(\n    msg: string,\n    opts: {status: number; statusText: string; body?: APIErrorBody | string}\n  ) {\n    super(msg);\n    this.name = \"SDKHttpError\";\n    this.status = opts.status;\n    this.statusText = opts.statusText;\n    this.body = opts.body;\n  }\n}\n\nexport class SDKTimeoutError extends Error {\n  constructor(public timeoutMs: number) {\n    super(`Request timed out after ${timeoutMs} ms`);\n    this.name = \"SDKTimeoutError\";\n  }\n}\n\n// -------- Domain payloads --------\nexport type TrackEventPayload = {\n  eventId: number; // numeric, defined in admin UI\n  userId: number | string;\n  itemId: number | string; // allow UUIDs or numeric IDs\n};\n\nexport type ItemUpsertPayload = {\n  itemId: number | string; // allow UUIDs or numeric IDs\n  name: string;\n  description: string;\n  metadata: Record<string, any>;\n};\n\nexport type RecommendationOptions = {\n  userId: number | string;\n  contextId?: string;\n  limit?: number;\n};\n\nexport type DeleteItemInput = {\n  itemId: string | number;\n};\n\nexport type DeleteItemsResponse = {\n  message: string;\n  itemId?: string | number;\n  itemIds: Array<string | number>;\n  deletedCount?: number;\n  processing_time_ms?: number;\n};\n\n// Example response shape; feel free to replace/extend with your real types\nexport type Recommendation = {\n  itemId: number | string;\n  score?: number;\n  reason?: string;\n  [k: string]: unknown;\n};\n\nexport class NeuronSDK {\n  private baseUrl: string;\n  private accessToken: string;\n  private timeoutMs: number;\n  private maxRetries: number;\n  private fetchImpl: typeof fetch;\n\n  constructor(config: SDKConfig) {\n    if (!config.baseUrl || !config.accessToken) {\n      throw new Error(\"baseUrl and accessToken are required\");\n    }\n    this.baseUrl = config.baseUrl.replace(/\\/+$/, \"\"); // trim trailing slashes\n    this.accessToken = config.accessToken;\n    this.timeoutMs = config.timeoutMs ?? 10_000;\n    this.maxRetries = config.maxRetries ?? 2;\n    this.fetchImpl = config.fetchImpl ?? (globalThis.fetch as typeof fetch);\n    if (!this.fetchImpl) {\n      throw new Error(\n        \"fetch is not available in this environment. Provide config.fetchImpl (e.g., undici or node-fetch).\"\n      );\n    }\n  }\n\n  public setAccessToken(token: string) {\n    this.accessToken = token;\n  }\n\n  public setBaseUrl(url: string) {\n    this.baseUrl = url.replace(/\\/+$/, \"\");\n  }\n\n  public setTimeout(ms: number) {\n    this.timeoutMs = ms;\n  }\n\n  private getHeaders(extra?: HeadersInit): HeadersInit {\n    return {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.accessToken}`,\n      ...(extra ?? {}),\n    };\n  }\n\n  // Core request with timeout + retry (429/5xx + timeouts)\n  private async request<T>(\n    pathOrUrl: string,\n    init: RequestInit & {retryOn?: number[]} = {}\n  ): Promise<T> {\n    const method = init.method ?? \"GET\";\n    const isAbs = /^https?:\\/\\//i.test(pathOrUrl);\n    const url = isAbs\n      ? pathOrUrl\n      : `${this.baseUrl}${pathOrUrl.startsWith(\"/\") ? \"\" : \"/\"}${pathOrUrl}`;\n\n    const retryOn = init.retryOn ?? [429, 500, 502, 503, 504];\n    let attempt = 0;\n    const requestId =\n      logger.shouldLog(\"DEBUG\") || logger.isPerformanceLoggingEnabled()\n        ? `${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`\n        : undefined;\n\n    while (true) {\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), this.timeoutMs);\n      const startTime = logger.isPerformanceLoggingEnabled() ? Date.now() : 0;\n\n      if (logger.shouldLog(\"DEBUG\")) {\n        logger.debug(\"HTTP request attempt\", {\n          method,\n          url,\n          attempt,\n          maxRetries: this.maxRetries,\n          retryOn,\n          requestId,\n          requestBody: typeof init.body === \"string\" ? init.body : undefined,\n        });\n      }\n\n      try {\n        const res = await this.fetchImpl(url, {\n          ...init,\n          signal: controller.signal,\n        });\n        clearTimeout(timeout);\n        const durationMs = startTime ? Date.now() - startTime : undefined;\n\n        if (res.ok) {\n          const text = await res.text();\n          if (logger.shouldLog(\"DEBUG\")) {\n            logger.debug(\"HTTP response received\", {\n              method,\n              url,\n              attempt,\n              status: res.status,\n              requestId,\n              durationMs,\n            });\n          }\n          if (text && logger.shouldLog(\"TRACE\")) {\n            logger.trace(\"HTTP response payload\", {\n              method,\n              url,\n              requestId,\n              responseBody: text,\n            });\n          }\n          if (!text) return undefined as unknown as T;\n          try {\n            return JSON.parse(text) as T;\n          } catch {\n            return text as unknown as T; // non-JSON payloads\n          }\n        }\n\n        const raw = await res.text().catch(() => \"\");\n        if (logger.shouldLog(\"WARN\")) {\n          logger.warn(\"HTTP response not OK\", {\n            method,\n            url,\n            attempt,\n            status: res.status,\n            statusText: res.statusText,\n            requestId,\n            durationMs,\n            responseBody: raw,\n          });\n        }\n        let body: APIErrorBody | string | undefined;\n        try {\n          body = raw ? (JSON.parse(raw) as APIErrorBody) : undefined;\n        } catch {\n          body = raw;\n        }\n\n        if (retryOn.includes(res.status) && attempt < this.maxRetries) {\n          attempt++;\n          const retryAfter = res.headers.get(\"retry-after\");\n          const delay =\n            retryAfter && !Number.isNaN(Number(retryAfter))\n              ? Number(retryAfter) * 1000\n              : this.backoffMs(attempt);\n          if (logger.shouldLog(\"INFO\")) {\n            logger.info(\"Retrying request after HTTP status\", {\n              method,\n              url,\n              attempt,\n              status: res.status,\n              delayMs: delay,\n              requestId,\n            });\n          }\n          await this.sleep(delay);\n          continue;\n        }\n\n        const msg = `HTTP ${res.status} ${res.statusText} for ${\n          method\n        } ${url}`;\n        throw new SDKHttpError(msg, {\n          status: res.status,\n          statusText: res.statusText,\n          body,\n        });\n      } catch (err: any) {\n        clearTimeout(timeout);\n\n        if (err?.name === \"AbortError\") {\n          if (attempt < this.maxRetries) {\n            attempt++;\n            if (logger.shouldLog(\"WARN\")) {\n              logger.warn(\"Retrying request after timeout\", {\n                method,\n                url,\n                attempt,\n                timeoutMs: this.timeoutMs,\n                requestId,\n              });\n            }\n            await this.sleep(this.backoffMs(attempt));\n            continue;\n          }\n          logger.error(\"Request aborted after max retries\", {\n            method,\n            url,\n            attempts: attempt,\n            timeoutMs: this.timeoutMs,\n            requestId,\n          });\n          throw new SDKTimeoutError(this.timeoutMs);\n        }\n\n        // transient network errors\n        if (attempt < this.maxRetries) {\n          attempt++;\n          if (logger.shouldLog(\"WARN\")) {\n            logger.warn(\"Retrying request after network error\", {\n              method,\n              url,\n              attempt,\n              error: err?.message,\n              requestId,\n            });\n          }\n          await this.sleep(this.backoffMs(attempt));\n          continue;\n        }\n        logger.error(\"Request failed\", {\n          method,\n          url,\n          attempts: attempt,\n          error: err?.message,\n          requestId,\n        });\n        throw err;\n      }\n    }\n  }\n\n  private backoffMs(attempt: number) {\n    // 300ms, 600ms, 1200ms ... + jitter\n    const base = 300 * Math.pow(2, attempt - 1);\n    const jitter = Math.random() * 200;\n    return base + jitter;\n  }\n\n  private sleep(ms: number) {\n    return new Promise((r) => setTimeout(r, ms));\n  }\n\n  // ----------------- Public API -----------------\n\n  /**\n   * Track an existing event occurrence.\n   * This does NOT create event definitions; it records that a pre-defined event happened.\n   * POST /events\n   */\n  public async trackEvent<T = {success: true; id?: number}>(\n    data: TrackEventPayload\n  ): Promise<T> {\n    if (\n      !data ||\n      typeof data.eventId !== \"number\" ||\n      (typeof data.userId !== \"number\" && typeof data.userId !== \"string\") ||\n      typeof data.itemId !== \"number\"\n    ) {\n      throw new Error(\"eventId and itemId must be numbers; userId must be a string or number\");\n    }\n\n    return this.request<T>(\"/events\", {\n      method: \"POST\",\n      headers: this.getHeaders(),\n      body: JSON.stringify(data),\n    });\n  }\n\n  /**\n   * @deprecated Use trackEvent(). Kept for backwards compatibility.\n   */\n  public async createEvent<T = {success: true; id?: number}>(\n    data: TrackEventPayload\n  ): Promise<T> {\n    return this.trackEvent<T>(data);\n  }\n\n  /**\n   * Create or update an item\n   * POST /items\n   */\n  public async upsertItem<T = {success: true; itemId: number | string}>(\n    data: ItemUpsertPayload\n  ): Promise<T> {\n    return this.request<T>(\"/items\", {\n      method: \"POST\",\n      headers: this.getHeaders(),\n      body: JSON.stringify(data),\n    });\n  }\n\n  /**\n   * Delete one or more items.\n   * DELETE /items\n   */\n  public async deleteItems<T = DeleteItemsResponse>(\n    items: DeleteItemInput | DeleteItemInput[]\n  ): Promise<T> {\n    const payload = Array.isArray(items) ? items : [items];\n\n    if (\n      payload.length === 0 ||\n      payload.some((entry) => {\n        const id = entry?.itemId;\n        const isValidString = typeof id === \"string\" && id.trim().length > 0;\n        const isValidPositiveInteger =\n          typeof id === \"number\" && Number.isInteger(id) && id > 0;\n        return !(isValidString || isValidPositiveInteger);\n      })\n    ) {\n      throw new Error(\"itemId is required and must be a UUID string or positive integer\");\n    }\n\n    const body = payload.length === 1 ? payload[0] : payload;\n\n    return this.request<T>(\"/items\", {\n      method: \"DELETE\",\n      headers: this.getHeaders(),\n      body: JSON.stringify(body),\n    });\n  }\n\n  /**\n   * Get recommendations for a user, optionally with a context ID and limit\n   * GET /recommendations?user_id=...&context_id=...&limit=...\n   */\n  public async getRecommendations<T = Recommendation[]>(\n    options: RecommendationOptions\n  ): Promise<T> {\n    const {userId, contextId, limit} = options;\n    if (typeof userId !== \"number\" && typeof userId !== \"string\") {\n      throw new Error(\"userId must be a string or number\");\n    }\n\n    const url = new URL(`${this.baseUrl}/recommendations`);\n    url.searchParams.set(\"user_id\", String(userId));\n    if (contextId) url.searchParams.set(\"context_id\", contextId);\n    if (typeof limit === \"number\") url.searchParams.set(\"limit\", String(limit));\n\n    return this.request<T>(url.toString(), {\n      method: \"GET\",\n      headers: this.getHeaders(),\n    });\n  }\n}\n\nexport default NeuronSDK;\n","export type LogLevelName = \"TRACE\" | \"DEBUG\" | \"INFO\" | \"WARN\" | \"ERROR\" | \"FATAL\";\n\nconst LEVEL_VALUES: Record<LogLevelName, number> = {\n  TRACE: 10,\n  DEBUG: 20,\n  INFO: 30,\n  WARN: 40,\n  ERROR: 50,\n  FATAL: 60,\n};\n\nexport type StructuredLogEntry = {\n  level: LogLevelName;\n  levelValue: number;\n  message: string;\n  timestamp: string;\n  context?: Record<string, unknown>;\n};\n\nexport type LoggerTransport = (entry: StructuredLogEntry) => void;\n\nexport type LoggerConfig = {\n  /**\n   * Global log level. TRACE is the most verbose, FATAL is the most quiet.\n   * Defaults to INFO for production-friendly output.\n   */\n  level?: LogLevelName | number;\n  /**\n   * When true, request/response bodies will be included in TRACE/DEBUG logs.\n   * Remains disabled by default to avoid leaking sensitive data.\n   */\n  enableNetworkBodyLogging?: boolean;\n  /**\n   * Enables timing/metric logging around HTTP calls. Disabled by default.\n   */\n  enablePerformanceLogging?: boolean;\n  /**\n   * Provide a custom log transport (e.g., ship logs to your own logger).\n   * Defaults to console.* for quick observability.\n   */\n  transport?: LoggerTransport;\n  /**\n   * Keys (case-sensitive) that should never be emitted. Defaults to common\n   * credential keys to guarantee that INFO/WARN/ERROR logs stay safe.\n   */\n  redactKeys?: string[];\n};\n\nconst DEFAULT_CONFIG: Required<Omit<LoggerConfig, \"transport\">> & {\n  transport: LoggerTransport;\n} = {\n  level: \"INFO\",\n  enableNetworkBodyLogging: false,\n  enablePerformanceLogging: false,\n  redactKeys: [\"accessToken\", \"authorization\", \"Authorization\"],\n  transport(entry) {\n    const method =\n      entry.level === \"TRACE\" || entry.level === \"DEBUG\"\n        ? \"debug\"\n        : entry.level === \"INFO\"\n          ? \"info\"\n          : entry.level === \"WARN\"\n            ? \"warn\"\n            : \"error\";\n    const prefix = `[NeuronSDK][${entry.level}] ${entry.message}`;\n    if (entry.context && Object.keys(entry.context).length > 0) {\n      console[method]?.(prefix, entry.context);\n    } else {\n      console[method]?.(prefix);\n    }\n  },\n};\n\nconst NETWORK_BODY_KEYS = new Set([\"requestBody\", \"responseBody\"]);\n\nexport class SDKLogger {\n  private config: Required<LoggerConfig>;\n  private levelValue: number;\n\n  constructor() {\n    this.config = {...DEFAULT_CONFIG};\n    this.levelValue = this.toLevelValue(this.config.level);\n  }\n\n  /**\n   * Configure the global logger.\n   *\n   * Development example (verbose logging + payloads):\n   * ```ts\n   * import {configureLogger} from \"@neuronsearchlab/sdk\";\n   * configureLogger({\n   *   level: \"TRACE\",\n   *   enableNetworkBodyLogging: true,\n   *   enablePerformanceLogging: true,\n   * });\n   * ```\n   *\n   * Production example (safe defaults):\n   * ```ts\n   * configureLogger({ level: \"INFO\" });\n   * ```\n   */\n  public configure(config: LoggerConfig = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n      transport: config.transport ?? this.config.transport,\n      redactKeys: config.redactKeys ?? this.config.redactKeys,\n    };\n    if (config.level !== undefined) {\n      this.levelValue = this.toLevelValue(config.level);\n      this.config.level = this.levelValueToName(this.levelValue);\n    }\n  }\n\n  public shouldLog(level: LogLevelName): boolean {\n    return this.toLevelValue(level) >= this.levelValue;\n  }\n\n  public isPerformanceLoggingEnabled(): boolean {\n    return this.config.enablePerformanceLogging && this.shouldLog(\"DEBUG\");\n  }\n\n  public canLogNetworkPayloads(level: LogLevelName): boolean {\n    return (\n      this.config.enableNetworkBodyLogging &&\n      this.shouldLog(level) &&\n      this.toLevelValue(level) <= this.toLevelValue(\"DEBUG\")\n    );\n  }\n\n  public trace(message: string, context?: Record<string, unknown>) {\n    this.log(\"TRACE\", message, context);\n  }\n\n  public debug(message: string, context?: Record<string, unknown>) {\n    this.log(\"DEBUG\", message, context);\n  }\n\n  public info(message: string, context?: Record<string, unknown>) {\n    this.log(\"INFO\", message, context);\n  }\n\n  public warn(message: string, context?: Record<string, unknown>) {\n    this.log(\"WARN\", message, context);\n  }\n\n  public error(message: string, context?: Record<string, unknown>) {\n    this.log(\"ERROR\", message, context);\n  }\n\n  public fatal(message: string, context?: Record<string, unknown>) {\n    this.log(\"FATAL\", message, context);\n  }\n\n  private log(level: LogLevelName, message: string, context?: Record<string, unknown>) {\n    if (!this.shouldLog(level)) return;\n    const entry: StructuredLogEntry = {\n      level,\n      levelValue: this.toLevelValue(level),\n      message,\n      timestamp: new Date().toISOString(),\n      context: this.sanitizeContext(level, context),\n    };\n    this.config.transport(entry);\n  }\n\n  private sanitizeContext(\n    level: LogLevelName,\n    context?: Record<string, unknown>\n  ): Record<string, unknown> | undefined {\n    if (!context) return undefined;\n    const sanitized: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(context)) {\n      if (this.config.redactKeys.includes(key)) {\n        sanitized[key] = \"[REDACTED]\";\n        continue;\n      }\n      if (\n        NETWORK_BODY_KEYS.has(key) &&\n        !(this.canLogNetworkPayloads(level) && typeof value !== \"undefined\")\n      ) {\n        continue;\n      }\n      sanitized[key] = value;\n    }\n    return Object.keys(sanitized).length > 0 ? sanitized : undefined;\n  }\n\n  private toLevelValue(level: LogLevelName | number): number {\n    if (typeof level === \"number\") {\n      return level;\n    }\n    return LEVEL_VALUES[level];\n  }\n\n  private levelValueToName(value: number): LogLevelName {\n    const found = (Object.entries(LEVEL_VALUES) as [LogLevelName, number][]).find(\n      ([, v]) => v === value\n    );\n    return found?.[0] ?? \"INFO\";\n  }\n}\n\nexport const logger = new SDKLogger();\nexport const configureLogger = (config: LoggerConfig) => logger.configure(config);\nexport type {LogLevelName as LogLevel};\n"],"mappings":"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","names":[]}